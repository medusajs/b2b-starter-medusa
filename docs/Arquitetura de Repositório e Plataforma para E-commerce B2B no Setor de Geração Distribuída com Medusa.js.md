Arquitetura de Repositório e Plataforma para E-commerce B2B no Setor de Geração Distribuída com Medusa.jsEste relatório apresenta uma arquitetura informacional detalhada e uma estratégia de implementação para a estruturação de um repositório GitHub, utilizando o framework medusa.js e o seu b2b-starter-medusa. O objetivo é construir uma plataforma de e-commerce robusta, escalável e de nível empresarial, projetada especificamente para o ecossistema de Geração Distribuída (GD). A arquitetura proposta atende às necessidades complexas e distintas das personas principais: proprietários de imóveis residenciais, comerciais e rurais; associados e afiliados; e clientes B2B profissionais, incluindo empresas e especialistas em elétrica, construção e automação.I. Arquitetura Fundamental: Alinhando o B2B Starter com a Lógica de Negócio CentralA fase inicial do projeto estabelece a configuração de base, mapeando as personas de negócio definidas para as primitivas B2B nativas fornecidas pelo Medusa.js. Esta camada fundamental é o alicerce sobre o qual todas as personalizações subsequentes serão construídas, garantindo que a plataforma aproveite ao máximo os recursos comprovados do framework antes de estendê-los.1.1. Desconstruindo o b2b-starter-medusaO b2b-starter-medusa serve como um acelerador de desenvolvimento, fornecendo o andaime essencial para uma configuração B2B.1 A sua análise revela três componentes principais: um backend Medusa pré-configurado, um storefront em Next.js e um conjunto de funcionalidades B2B essenciais ativadas por padrão. Este starter, embora não seja uma solução completa "out-of-the-box" para os requisitos específicos deste projeto, constitui o ponto de partida ideal.2 A estrutura inicial do repositório, com os seus diretórios backend e storefront, será mapeada diretamente para os componentes deste starter. A plataforma Medusa é projetada para ser extensível, e este starter fornece a base sobre a qual módulos personalizados, modelos de dados complexos e lógicas de negócio específicas do domínio serão construídos.31.2. Segmentação de Personas Utilizando Primitivas MedusaA segmentação eficaz dos utilizadores é a pedra angular de uma experiência de e-commerce B2B bem-sucedida. O Medusa.js oferece dois mecanismos primários para alcançar esta segmentação: Grupos de Clientes (Customer Groups) e Canais de Venda (Sales Channels).Grupos de Clientes (Customer Groups)Os Customer Groups são o mecanismo principal para a segmentação funcional e de preços. Eles permitem organizar clientes em coortes distintas, às quais podem ser aplicadas regras de negócio específicas, como listas de preços personalizadas.2 Para este projeto, serão definidos os seguintes grupos:CG_PRO_INSTALLER: Destinado a profissionais verificados (eletricistas, empresas de construção, integradores de automação). Este grupo terá acesso a preços de atacado, funcionalidades de compra em volume e produtos técnicos especializados.CG_AFFILIATE: Para associados e parceiros inscritos no programa de afiliados da plataforma. A associação a este grupo desbloqueará o acesso ao portal de afiliados e às suas ferramentas.CG_OWNER_RESIDENTIAL: Para proprietários de imóveis residenciais.CG_OWNER_COMMERCIAL: Para proprietários ou gestores de imóveis comerciais.CG_OWNER_RURAL: Para proprietários de imóveis rurais.Estes três últimos grupos (OWNER_*) permitirão a personalização de conteúdo, recomendações de produtos (como kits de instalação) e campanhas de marketing direcionadas para o mercado de utilizadores finais.Canais de Venda (Sales Channels)Enquanto os Customer Groups controlam o "quem" e o "quanto", os Sales Channels governam o "o quê". Eles são utilizados para controlar a visibilidade e a disponibilidade de produtos, criando experiências de storefront distintas para diferentes segmentos de mercado.2 A arquitetura utilizará os seguintes canais:SC_B2B_PROFESSIONAL: Um canal que conterá o catálogo completo de componentes técnicos, equipamentos avulsos e produtos vendidos em volume. Este será o canal principal para os membros do grupo CG_PRO_INSTALLER.SC_DTC_OWNER: Um canal focado no consumidor final, apresentando um catálogo curado de kits solares, soluções "faça você mesmo" (DIY), materiais educativos e produtos orientados para soluções, em vez de componentes individuais.5SC_AFFILIATE_LANDING: Um canal potencialmente dinâmico que pode ser usado para isolar produtos específicos apresentados em campanhas de afiliados, permitindo a criação de páginas de destino otimizadas.A associação de uma Chave de API Publicável (Publishable API Key) a um ou mais canais de venda é a prática recomendada pelo Medusa para garantir que um cliente, como o storefront Next.js, recupere apenas os produtos relevantes para o contexto do utilizador autenticado.21.3. Estratégia de Metadados para Sobreposição de Papéis e PermissõesAs primitivas padrão do Medusa são excelentes para uma segmentação ampla, mas podem criar fronteiras rígidas. Um utilizador ou está num grupo ou não está. No entanto, no mundo real, as personas podem sobrepor-se: um eletricista (CG_PRO_INSTALLER) pode também ser proprietário de um imóvel rural (CG_OWNER_RURAL) e desejar comprar um sistema para a sua própria propriedade. Para gerir esta fluidez, será implementada uma estratégia de metadados robusta na entidade Customer.Um esquema de metadados padronizado será definido para lidar com utilizadores que podem incorporar múltiplas personas. Por exemplo, um objeto de metadados na entidade Customer poderia ter a seguinte estrutura: { "is_installer": true, "affiliate_id": "aff-123", "property_type": "rural" }. Esta abordagem é uma extensão do padrão sugerido na documentação do Medusa de usar um sinalizador como is_b2b nos metadados do grupo de clientes, aplicando-o a um nível mais granular no próprio cliente para um controlo mais fino.4Esta estratégia, no entanto, é apenas o primeiro passo. A verdadeira necessidade do negócio é gerir um conjunto dinâmico de permissões e experiências com base nos papéis combinados de um utilizador. Para resolver isto de forma escalável, a arquitetura irá além dos metadados estáticos e introduzirá uma camada de lógica centralizada: um "Serviço de Persona" (PersonaService) personalizado no backend do Medusa. Quando um utilizador inicia sessão, este serviço será invocado. Ele irá analisar os customer.groups e os customer.metadata do utilizador para resolver a sua "persona efetiva" em tempo de execução. O serviço retornará um objeto consolidado que informa o resto da aplicação sobre as capacidades do utilizador, como por exemplo: { roles: ['installer', 'owner_rural'], effective_pricing_tier: 'installer_plus', accessible_channels: }. Esta abordagem transforma o repositório de uma configuração estática de grupos para um sistema dinâmico que se adapta a identidades de utilizador complexas, representando uma arquitetura muito mais realista e preparada para o futuro.II. Estrutura Hierárquica para Gestão Avançada de Contas B2BEsta secção detalha a arquitetura de um módulo personalizado essencial para gerir as relações comerciais complexas inerentes à base de utilizadores profissionais. A solução vai além do modelo Customer padrão do Medusa para introduzir um sistema de gestão de contas empresariais hierárquico e completo.2.1. Justificativa para um Módulo Company PersonalizadoAs capacidades B2B padrão do Medusa são poderosas, mas centram-se em Customer Groups e Price Lists.2 Estas funcionalidades não abrangem nativamente o conceito de uma "Conta Empresarial" hierárquica, que inclui múltiplos funcionários, diferentes papéis, permissões de compra e limites de crédito. Starters B2B comerciais e soluções de mercado demonstram a necessidade crítica de funcionalidades como gestão de funcionários da empresa, permissões baseadas em papéis e limites de gastos configuráveis, que devem ser construídas de forma personalizada para atender a estes requisitos avançados.7 A criação de um módulo Company dedicado é, portanto, um requisito arquitetónico fundamental.2.2. Arquitetura do Modelo de Dados (src/models/)Para implementar esta funcionalidade, serão criados novos modelos de dados que se estendem e se relacionam com as entidades principais do Medusa:Company.ts: A entidade central que representa uma empresa cliente. Armazenará informações como o nome da empresa, número de identificação fiscal, múltiplos endereços (faturação, entrega), limites de crédito aprovados e o grupo de clientes programático associado.Employee.ts: Uma entidade de ligação que estabelece a relação entre um Customer do Medusa e uma Company. Este modelo é crucial, pois conterá o papel do funcionário dentro da empresa (por exemplo, admin, purchaser, viewer), implementando diretamente a funcionalidade de "gestão de funcionários da empresa com permissões baseadas em papéis".7Project.ts: Uma entidade personalizada para permitir que as empresas giram o aprovisionamento para múltiplas instalações ou obras distintas. Um funcionário poderá gerir múltiplos carrinhos de compras, com cada carrinho associado a um Project. Isto aborda a necessidade de "gestão de múltiplos carrinhos" 7 de uma forma específica para o domínio da construção e instalação.2.3. Camada de Serviço e API (src/services/, src/api/)A lógica de negócio para estas novas entidades será encapsulada em serviços dedicados e exposta através de uma API REST personalizada:CompanyService.ts: Conterá a lógica de negócio para criar empresas, validar os seus dados, convidar funcionários, gerir papéis e aplicar regras de negócio, como a verificação de limites de crédito.Endpoints da API: Serão criadas rotas de API personalizadas, seguindo o padrão de extensão padrão do Medusa 3:POST /store/companies: Para permitir que um profissional verificado registe a sua empresa.GET /store/companies/me: Para que um funcionário autenticado visualize os detalhes da sua empresa e os projetos associados.POST /store/companies/me/employees: Para que um administrador da empresa convide novos funcionários para a conta.PUT /store/companies/me/employees/{employee_id}: Para que um administrador da empresa atualize o papel de um funcionário.2.4. Extensões da Interface de Administração (src/admin/)Para que a equipa interna possa gerir estas novas contas B2B, a interface de administração do Medusa será estendida. Utilizando as capacidades de extensão do Medusa Admin, como Widgets e UI Routes 2, será construída uma interface de gestão dedicada:Um novo item de menu na barra lateral, "Empresas", levará a uma UI Route personalizada que exibe uma lista de todas as empresas registadas, com funcionalidades de pesquisa e filtragem.Na página de detalhes de uma empresa, um Widget personalizado será injetado para exibir uma lista dos seus funcionários, projetos em andamento e as Price Lists específicas associadas a essa empresa.Uma abordagem poderosa para alavancar o motor de preços principal do Medusa para clientes B2B é criar programaticamente um Customer Group único e dedicado para cada entidade Company no momento da sua criação. Esta estratégia estabelece uma ligação direta e um-para-um, permitindo a aplicação de preços verdadeiramente específicos da empresa através das Price Lists do Medusa, sem poluir os grupos de clientes globais. O requisito de negocio é oferecer preços especiais e negociados a empresas específicas 4, e o mecanismo de Price List do Medusa funciona aplicando sobreposições de preços a Customer Groups.6 Uma abordagem simplista seria criar um grupo genérico como "Empresas de Nível 1", mas este modelo falha quando a Empresa A negocia um preço especial num inversor específico que a Empresa B não obtém.A solução arquitetónica superior é que o CompanyService, ao criar uma nova Company, execute também automaticamente uma operação para criar um novo grupo de clientes, por exemplo, customerGroupService.create({ name: 'CG_COMPANY_ACME_INC' }). Este grupo seria então associado à entidade Company. Subsequentemente, quando um funcionário da "ACME Inc" é adicionado à plataforma, ele é automaticamente adicionado ao grupo CG_COMPANY_ACME_INC. Isto permite que um utilizador administrativo aceda à secção "Preços" do Medusa Admin e crie uma Price List que se aplica exclusivamente ao grupo CG_COMPANY_ACME_INC. Esta é uma integração perfeita da lógica personalizada com uma funcionalidade central do Medusa, proporcionando um poder e uma flexibilidade imensos sem a necessidade de reconstruir todo o motor de preços. É um padrão arquitetónico não óbvio, mas crítico, para uma personalização B2B profunda no Medusa.III. Desenho do Módulo de Ecossistema de Afiliados e ParceirosEsta secção descreve a criação de um módulo dedicado para gerir a persona de "associados e afiliados". A arquitetura proposta fornece uma solução completa para a gestão de parceiros, rastreio de referências, cálculo de comissões e pagamentos, transformando o programa de afiliados numa ferramenta de crescimento estratégico.3.1. Requisitos Essenciais para um Programa de Afiliados B2BAo contrário dos programas de afiliados B2C simples, o marketing de afiliados B2B exige um rastreio robusto, estruturas de comissão flexíveis e um portal de parceiros profissional.11 O foco muitas vezes não está apenas em vendas únicas, mas sim na geração de leads qualificados (CPL - Cost Per Lead) e na receita recorrente (SaaS), o que é relevante para a venda de sistemas e serviços de manutenção.13 O sistema deve fornecer aos afiliados um portal personalizado onde possam visualizar o seu desempenho, aceder a materiais de marketing e monitorizar as suas comissões em tempo real.113.2. Arquitetura do Modelo de Dados (src/models/)Um novo conjunto de entidades será criado para suportar o ecossistema de afiliados:AffiliateProfile.ts: Ligado a um Customer do Medusa (que pertence ao grupo CG_AFFILIATE). Armazenará informações específicas do afiliado, como o seu código de referência único, detalhes de pagamento (por exemplo, PayPal, transferência bancária) e a estrutura de comissão que lhe foi atribuída.ReferralLink.ts: Armazenará links de rastreio únicos gerados pelos afiliados. Incluirá metadados para o rastreio de campanhas específicas, permitindo analisar a eficácia de diferentes promoções.CommissionRule.ts: Um modelo flexível para definir a lógica de comissão. Isto permite uma grande variedade de modelos de incentivo. Exemplos: { event: 'order.placed', type: 'percentage', value: 5 } ou { event: 'customer.created', type: 'fixed', value: 50, requires_first_order: true }. Esta abordagem implementa diretamente a necessidade de modelos de comissão flexíveis e baseados em eventos.12TrackedEvent.ts: Registará cada ação rastreada, como um clique, um registo de utilizador ou uma conversão, ligando-a ao afiliado, ao cliente de origem e à regra de comissão aplicável.PayoutRecord.ts: Registará cada pagamento, seja ele automático ou manual, feito a um afiliado, garantindo uma trilha de auditoria clara e transparente para ambas as partes.3.3. Lógica e Gestão de Eventos (src/subscribers/, src/services/)A automação é fundamental para a escalabilidade de um programa de afiliados. A arquitetura irá alavancar o poderoso sistema de eventos do Medusa 3:AffiliateService.ts: O serviço central que gere o onboarding de afiliados, a geração de links, o cálculo de comissões e o processamento de pagamentos.Subscritores de Eventos: Módulos que "ouvem" os eventos principais do Medusa para acionar a lógica de afiliados:OrderPlacedSubscriber.ts: Ouve o evento order.placed. Se a encomenda pertencer a um cliente que foi referido por um afiliado (identificado através de um cookie ou metadados do cliente), o serviço calculará e registará a comissão devida.CustomerCreatedSubscriber.ts: Pode ser utilizado para modelos CPL, onde os afiliados são recompensados por cada novo registo de cliente qualificado que geram.3.4. O Portal do Afiliado (Personalização do Storefront)Uma secção dedicada do storefront Next.js será construída para servir como o painel de controlo (dashboard) para os afiliados autenticados. Esta área será o seu centro de operações e incluirá as seguintes funcionalidades:Painel de Desempenho em Tempo Real: Gráficos e métricas que exibem cliques, conversões, ganhos pendentes e ganhos pagos.11Gerador de Links: Uma ferramenta que permite aos afiliados gerar links de rastreio para qualquer página ou produto da plataforma.Biblioteca de Ativos de Marketing: Acesso a uma coleção de banners, logótipos, descrições de produtos e outros materiais promocionais para facilitar as suas campanhas.Histórico de Pagamentos e Configurações: Uma visão detalhada de todos os pagamentos recebidos e a capacidade de atualizar as suas informações de pagamento.Este portal será alimentado por endpoints de API personalizados e seguros no backend do Medusa (por exemplo, GET /store/affiliates/me/stats).Para referências B2B de alto valor, como a indicação de uma grande instalação comercial, a venda final pode ocorrer offline ou após um longo ciclo de vendas. Confiar exclusivamente em cookies de navegador e eventos de order.placed do e-commerce é insuficiente e falhará em compensar adequadamente parceiros valiosos. O ciclo de vendas B2B é longo e envolve múltiplos intervenientes.11 Um afiliado pode referir um lead que preenche um formulário de "Pedir Orçamento". Este lead é então nutrido pela equipa de vendas num CRM (por exemplo, Salesforce, HubSpot), e o negócio pode fechar três meses depois. Plataformas de parceiros B2B profissionais, como o PartnerStack, destacam explicitamente o "Rastreio Conectado ao CRM" para sincronizar leads originados por parceiros e acompanhar a sua progressão através do ciclo de vendas.12Portanto, a arquitetura do módulo de Affiliate não deve apenas ouvir os eventos do Medusa, mas também ser capaz de receber eventos de um CRM através de webhooks. A arquitetura deve incluir um endpoint genérico, como POST /api/hooks/crm-event. Quando um negócio no CRM, marcado com o ID de referência de um afiliado, é movido para o estado "Fechado-Ganho", o CRM enviará um webhook para este endpoint. Este endpoint, por sua vez, acionará o AffiliateService para calcular e atribuir a comissão, criando um TrackedEvent com uma fonte de crm. Isto transforma o programa de afiliados de um simples complemento de e-commerce numa ferramenta de desenvolvimento de negócios séria, que atribui receita com precisão e se alinha com a forma como as vendas B2B de alto valor realmente funcionam.IV. Arquitetura de Informação para Dados Técnicos e de Produtos ComplexosEsta secção aborda o requisito crítico de gerir especificações técnicas detalhadas para os produtos da plataforma. Esta funcionalidade é essencial para a persona de utilizadores profissionais, que baseiam as suas decisões de compra em dados técnicos precisos e não em descrições de marketing.4.1. O Desafio dos Dados Técnicos no E-commerceInstaladores profissionais, engenheiros e arquitetos não compram painéis solares, inversores ou componentes elétricos com base em imagens de estilo de vida; eles utilizam dados concretos para garantir a compatibilidade, o desempenho e a segurança dos sistemas que projetam e instalam.5 A plataforma deve ser capaz de armazenar, exibir e permitir a filtragem por dezenas de parâmetros técnicos por produto. Exemplos incluem, para painéis solares: potência máxima (Pmax​), tensão de circuito aberto (Voc​), corrente de curto-circuito (Isc​), coeficientes de temperatura, cargas mecânicas e dimensões.15 Para inversores, os parâmetros incluem: potência nominal, tensão de entrada DC, gama de tensão MPPT, forma de onda, eficiência e classificação IP.194.2. Modelação de Dados: Entidades Personalizadas Vs. MetadadosA decisão arquitetónica mais crítica para os dados de produtos é como modelar estas especificações técnicas. Existem duas abordagens principais:Utilizar o campo Product.metadata do Medusa: Armazenar todas as especificações como um objeto JSON. Esta abordagem é simples de implementar inicialmente.Criar uma Entidade Personalizada Vinculada: Definir uma nova tabela na base de dados (por exemplo, ProductTechnicalSpecification) com colunas fortemente tipadas para cada especificação, vinculada através de uma relação um-para-um com a entidade ProductVariant do Medusa.A recomendação definitiva para este projeto é a abordagem da Entidade Personalizada Vinculada. O campo metadata, embora útil para dados simples e não estruturados, torna-se um obstáculo para dados complexos e consultáveis. A necessidade de filtragem avançada por parte das personas profissionais 24 torna o desempenho e a integridade dos dados não negociáveis. Consultar valores dentro de um campo JSONB para intervalos numéricos (por exemplo, WHERE metadata->>'pmax_wp'::int > 400) é significativamente menos performante e mais complexo do que uma consulta SQL padrão numa coluna indexada e tipada. Além disso, a integridade dos dados está em risco; com metadados, um produto pode ter "pmax": "450W" (uma string) enquanto outro tem "pmax": 450 (um número), levando a bugs. Uma tabela relacional com uma coluna pmax_wp INT impõe consistência.A tabela seguinte fornece uma justificação clara e baseada em dados para a escolha da abordagem de entidade personalizada.CritérioProduct.metadata (Campo JSONB)Entidade Personalizada Vinculada (PanelSpecification)Justificativa e RecomendaçãoDesempenho da ConsultaFraco para filtragem complexa (ex: intervalos numéricos). Requer indexação especial (GIN) e sintaxe de consulta complexa.Excelente. Permite consultas SQL padrão e de alto desempenho em colunas indexadas e fortemente tipadas.Para uma plataforma onde a filtragem técnica é uma funcionalidade central, o desempenho não é negociável. A Entidade Personalizada é superior.Integridade dos DadosBaixa. Nenhuma imposição de tipos de dados ou campos obrigatórios. Propenso a erros de digitação e inconsistências (ex: "450W" vs. 450).Alta. Impõe tipos de dados (ex: INT, FLOAT), restrições (ex: NOT NULL) e estrutura ao nível da base de dados.Crítico para dados de engenharia onde a precisão é primordial. A Entidade Personalizada é essencial.EscalabilidadeTorna-se difícil de gerir à medida que o número de especificações cresce. Difícil de gerir e migrar um grande esquema JSON não estruturado.Altamente escalável. Novos tipos de especificação (ex: BatterySpecification) podem ser adicionados como novas tabelas sem afetar as existentes.A plataforma irá inevitavelmente adicionar novas categorias de produtos. A arquitetura deve suportar isso de forma elegante. A Entidade Personalizada é a única opção escalável.Experiência do DesenvolvedorFraca. Nenhuma segurança de tipo a partir da base de dados. Requer validação e análise constantes na camada da aplicação.Excelente. As entidades TypeORM/MikroORM fornecem segurança de tipo total e autocompletar desde o backend até ao frontend.Uma melhor DX leva a um desenvolvimento mais rápido e a menos bugs. A Entidade Personalizada proporciona uma DX superior.Contrato da APIFraco. A API retorna um objeto metadata não estruturado, que é um contrato imprevisível para os consumidores da API.Forte. A API retorna um objeto panel_specification bem definido e versionável com um esquema claro.Um contrato de API forte é vital para o desenvolvimento do storefront e futuras integrações. A Entidade Personalizada é a escolha profissional.4.3. Modelo de Dados Proposto (src/models/)Para evitar uma única tabela de especificações sobrecarregada, serão criados modelos de especificação separados para diferentes tipos de produtos:PanelSpecification.ts: Vinculado à entidade ProductVariant. Campos incluirão: pmax_wp, voc_v, isc_a, vmp_v, imp_a, efficiency_percent, temp_coeff_pmax, dimensions_mm, weight_kg, etc..15InverterSpecification.ts: Vinculado à entidade ProductVariant. Campos incluirão: rated_power_kw, peak_power_va, dc_voltage_range, mppt_voltage_range, max_ac_current_a, waveform, efficiency_percent, ip_rating, etc..194.4. Estratégia de ImplementaçãoA implementação desta arquitetura de dados envolverá trabalho em todas as camadas da aplicação:Backend: Os tipos de resposta da API de produtos (StoreProductsListRes, StoreProductsRes) serão estendidos para incluir as novas relações de especificação, garantindo que estes dados sejam retornados de forma eficiente.Storefront: Será construída uma interface de pesquisa e filtragem facetada que permite aos utilizadores refinar a lista de produtos com base nestes parâmetros técnicos (por exemplo, "Mostrar todos os painéis com Pmax​>400W e Voc​<50V").Admin: A página "Editar Produto" na interface de administração será estendida com um formulário personalizado para gerir as especificações técnicas de cada variante de produto.V. Uma Estratégia de Monorepo Unificado para Desenvolvimento EscalávelEsta secção define a estrutura de alto nível do próprio repositório GitHub, defendendo a adoção de um monorepo para gerir as partes interconectadas da aplicação de forma coesa e eficiente.5.1. Justificativa para um MonorepoO projeto consiste em múltiplos pacotes fortemente acoplados: o backend Medusa, o storefront Next.js, as extensões de administração e a lógica partilhada. Manter estes projetos em repositórios separados (polyrepo) introduz complexidade na gestão de dependências, na consistência do código e na coordenação de lançamentos. Um monorepo, gerido com ferramentas como Turborepo ou Nx, simplifica estes desafios, melhora a colaboração entre equipas e otimiza os pipelines de CI/CD.5.2. Estrutura de Repositório PropostaA estrutura de diretórios do monorepo será organizada para promover uma clara separação de responsabilidades:/
├── apps/
│   ├── backend/         # A aplicação backend Medusa
│   ├── storefront/      # A aplicação storefront Next.js
│   └── admin/           # O Medusa admin, com extensões personalizadas
└── packages/
    ├── ui/              # Componentes React partilhados (botões, cartões, etc.)
    ├── config/          # Configurações partilhadas (ESLint, TypeScript)
    └── shared-types/    # CRÍTICO: Tipos e interfaces TypeScript partilhados
5.3. O Papel Crítico do Pacote shared-typesO pacote shared-types é o pilar do sucesso do monorepo. Ele conterá as definições TypeScript para todas as entidades personalizadas (Company, Employee, Project, AffiliateProfile, PanelSpecification, etc.) e para os DTOs (Data Transfer Objects) da API. Tanto a aplicação backend como a storefront consumirão este pacote. Isto garante que os contratos de dados entre a API e o cliente estão sempre sincronizados, eliminando uma fonte comum e frustrante de bugs no desenvolvimento headless. Qualquer alteração no modelo de dados no backend que quebre o contrato será imediatamente detetada pelo compilador TypeScript no storefront, antes mesmo de o código ser enviado para o repositório.Além da partilha de código, um monorepo bem estruturado ativamente encoraja e impõe uma arquitetura modular e componível. Ao separar fisicamente as preocupações em pacotes distintos (ui, shared-types), ele força os desenvolvedores a pensar em termos de APIs públicas e fronteiras bem definidas entre os componentes. Por exemplo, quando um desenvolvedor precisa de um novo botão, a estrutura do monorepo guia-o a adicioná-lo ao pacote packages/ui em vez de criá-lo dentro de uma página específica na aplicação storefront. Este processo exige que o botão seja projetado como um componente genérico e reutilizável com uma API clara (as suas props). Da mesma forma, ao definir a estrutura de dados da Company, ela deve ser colocada em packages/shared-types, forçando o desenvolvedor a considerar a sua estrutura independentemente do seu uso específico no backend ou no storefront. Este processo, repetido em toda a aplicação, leva naturalmente a um sistema composto por módulos pequenos, independentes e reutilizáveis, em vez de uma única aplicação monolítica e emaranhada. A própria estrutura do repositório torna-se uma ferramenta que impõe boas práticas arquitetónicas, um benefício crucial para a saúde a longo prazo do projeto.VI. Roteiro Estratégico de Implementação e RecomendaçõesEsta secção final sintetiza o plano arquitetónico num roteiro de implementação acionável e faseado. A abordagem prioriza funcionalidades para maximizar o valor entregue em cada fase e mitigar os riscos do projeto, concentrando-se primeiro nas funcionalidades de maior complexidade e valor de negócio.6.1. Fase 1: O Núcleo B2B Profissional (Meses 1-3)Foco: Servir a persona de utilizador mais crítica e tecnicamente exigente: o instalador profissional. A validação do modelo de negócio com este grupo é fundamental para o sucesso da plataforma.Tarefas:Configurar o monorepo e a aplicação base b2b-starter-medusa.Implementar a segmentação fundamental de personas (Grupos de Clientes, Canais de Venda) conforme detalhado na Secção I.Construir o módulo Company completo (Secção II). Isto inclui contas de empresa, papéis de funcionários, gestão de projetos e a lógica de grupos de clientes programáticos.Construir a arquitetura completa de dados de produtos (Secção IV). Implementar as entidades personalizadas para especificações de painéis e inversores, bem como a interface de administração correspondente e a filtragem no storefront.Objetivo: No final desta fase, um instalador profissional deve ser capaz de registar a sua empresa, convidar membros da equipa, navegar por um catálogo com especificações técnicas detalhadas, filtrar produtos com base em parâmetros de engenharia e adquirir equipamentos para um projeto.6.2. Fase 2: O Motor de Crescimento - Afiliados (Meses 4-5)Foco: Construir as ferramentas para escalar a aquisição de clientes e expandir o alcance da plataforma através de parcerias.Tarefas:Desenvolver o módulo Affiliate (Secção III). Isto inclui os modelos de dados, os subscritores de eventos, os endpoints da API e a lógica de comissão, incluindo a integração com o CRM.Construir o Portal do Afiliado no storefront para que os parceiros possam gerir as suas contas, gerar links e acompanhar o seu desempenho.Objetivo: Lançar um programa de afiliados totalmente funcional para impulsionar o tráfego e os leads para o núcleo B2B, agora estável e comprovado.6.3. Fase 3: Expansão de Mercado - Proprietários de Imóveis e Conteúdo (Mês 6+)Foco: Abordar as personas de estilo DTC/B2C (proprietários de imóveis) e estabelecer a plataforma como uma autoridade no setor.Tarefas:Utilizar os Sales Channels estabelecidos para criar uma experiência de storefront curada para proprietários de imóveis residenciais, comerciais e rurais.Desenvolver conteúdo educativo, guias de "como começar", estudos de caso e pacotes de soluções (inspirado em 5).Integrar ferramentas interativas, como calculadoras solares, que aproveitam os dados técnicos estruturados construídos na Fase 1 para fornecer estimativas precisas aos utilizadores.24Objetivo: Expandir o alcance da plataforma para os utilizadores finais, alavancando a robusta base técnica para lhes fornecer soluções confiáveis e baseadas em dados.6.4. Recomendações ChaveTestes: Implementar uma estratégia de testes abrangente desde o início. Isto deve incluir testes unitários para os serviços, testes de integração para os endpoints da API e testes end-to-end (por exemplo, utilizando Playwright ou Cypress) para os fluxos de utilizador críticos, como o checkout B2B, o convite de funcionários e o registo de afiliados.CI/CD: Aproveitar as ferramentas de CI/CD com reconhecimento de monorepo (por exemplo, GitHub Actions com filtragem de caminhos) para construir e implementar apenas as aplicações/pacotes que foram alterados, otimizando a eficiência do pipeline e reduzindo os tempos de implementação.Infraestrutura: Considerar a utilização das opções de alojamento na nuvem do Medusa ou uma implementação baseada em contentores (por exemplo, Docker em AWS/GCP) para garantir a escalabilidade, a fiabilidade e a tolerância a falhas à medida que a plataforma cresce.27VII. Jornadas dos Usuários, Rotas, JTBDs, Inputs e Outputs

1) Persona: Admin da Empresa (Instalador Profissional – CG_PRO_INSTALLER)
- JTBDs
  - Quando inicio a operação B2B, quero registrar minha empresa e configurar minha equipe, para que possamos comprar com preços e limites adequados.
  - Quando preciso controlar gastos, quero definir papéis e aprovações, para mitigar riscos e manter compliance.
  - Quando preciso negociar, quero solicitar e acompanhar cotações, para fechar compras complexas com melhores condições.

- Jornada A: Onboarding da Empresa
  - Storefront
    - GET /[countryCode]/login
    - GET /[countryCode]/account/company (dashboard)
    - GET /[countryCode]/account/company/new
  - API (Store)
    - POST /store/companies
      - Inputs (form/payload): name, tax_id, billing_address, shipping_address, contact, metadata
      - Outputs (201): company_id, customer_group_id, employee_id (role=admin), approval_settings seeded
    - GET /store/companies/me (200): company, employees, projects, pricing_group
  - Regras
    - Ao criar Company: criar Customer Group dedicado; linkar employee admin; seed de approval settings.
  - Erros
    - 400 dados inválidos; 409 company/tax_id já existente.

- Jornada B: Convite e gestão de colaboradores
  - Storefront
    - GET /[countryCode]/account/company/employees
    - GET /[countryCode]/account/company/employees/invite
  - API (Store)
    - POST /store/companies/me/employees
      - Inputs: email, role
      - Outputs (201): invite_id, employee_stub, email_status
    - POST /store/companies/me/employees/{employee_id}
      - Inputs: role
      - Outputs (200): employee atualizado
  - Erros
    - 403 se caller não for admin; 409 e-mail já associado.

- Jornada C: Carrinho com aprovação e limites
  - Storefront
    - GET /[countryCode]/products
    - GET /[countryCode]/products/[handle]
    - GET /[countryCode]/cart
  - API (Store)
    - POST /store/carts (201): cart_id, region_id
    - POST /store/carts/{cart_id}/line-items
      - Inputs: variant_id, quantity, metadata.project_id?
      - Outputs (200): cart atualizado
    - Hooks/Workflows
      - validate-add-to-cart: aplica limites de gasto por employee/company; sinaliza necessidade de aprovação no cart.metadata
  - Erros
    - 422 limite excedido ou item exige aprovação técnica.

- Jornada D: Solicitar cotação (RFQ) e acompanhar
  - Storefront
    - GET /[countryCode]/rfq
    - GET /[countryCode]/account/quotes
    - GET /[countryCode]/account/quotes/[quote_id]
  - API (Store)
    - POST /store/quotes/requests
      - Inputs: cart_id, notes, attachments?
      - Outputs (201): quote_id, status=pending, linked_draft_order
    - GET /store/quotes?company_id=... (200): { data, metadata }
  - Erros
    - 409 carrinho vazio; 403 sem permissão.

- Jornada E: Aprovação e Checkout
  - Storefront
    - GET /[countryCode]/account/approvals
    - GET /[countryCode]/checkout
  - API (Store)
    - GET /store/approvals/me (200): approvals pendentes
    - POST /store/approvals/{approval_id}/approve|reject (200): status
    - POST /store/carts/{cart_id}/payment-sessions (200)
    - POST /store/carts/{cart_id}/complete (201): order_id
  - Hooks
    - validate-cart-completion: bloqueia enquanto approval.status != approved

2) Persona: Comprador/Colaborador (Employee – purchaser/viewer)
- JTBDs
  - Quando compro para um projeto, quero montar carrinho por obra, para separar orçamentos e fluxos de aprovação.
  - Quando o limite estoura, quero ver o motivo e próxima ação, para agilizar aprovação.
- Jornada (resumo)
  - Storefront: /[countryCode]/projects, /[countryCode]/cart, /[countryCode]/checkout
  - Inputs: project selection (metadata.project_id), quantities
  - Outputs: feedback de validações (limite, aprovação), status do cart e do approval
  - Erros: 403 se tentar ação de admin; 422 validações de limite/estoque.

3) Persona: Afiliado/Parceiro (CG_AFFILIATE)
- JTBDs
  - Quando promovo a plataforma, quero gerar links e acompanhar conversões, para otimizar campanhas e rendimentos.
  - Quando um deal fecha no CRM, quero ver comissões refletidas, para ter confiança no programa.
- Jornada A: Onboarding e geração de links
  - Storefront
    - GET /[countryCode]/affiliate/apply
    - GET /[countryCode]/affiliate/dashboard
  - API (Store)
    - POST /store/affiliates/apply
      - Inputs: profile, payout_method, tax_info
      - Outputs (201): affiliate_profile_id, referral_code
    - POST /store/affiliates/me/links
      - Inputs: target_url, campaign
      - Outputs (201): referral_link_id, url_com_tracking
    - GET /store/affiliates/me/stats (200): clicks, signups, orders, pending/paid
- Jornada B: Atribuição por e-commerce e por CRM
  - Middleware storefront: seta cookie affiliate_ref ao detectar ?ref=...
  - Eventos medusa: order.placed -> calcula comissão via AffiliateService
  - Webhook CRM
    - POST /api/hooks/crm-event
      - Inputs: { event: 'deal.closed_won', referral_code, amount, currency, deal_id }
      - Outputs (202): tracked_event_id; comissão registrada
  - Erros
    - 400 evento inválido; 404 referral desconhecido; 409 duplicidade de deal.

4) Persona: Proprietário (DTC – CG_OWNER_*)
- JTBDs
  - Quando busco soluções, quero filtrar por dados técnicos relevantes, para encontrar kits adequados ao meu imóvel.
- Jornada
  - Storefront: /[countryCode]/kits, /[countryCode]/learn, /[countryCode]/products?filters=...
  - API (Store): GET /store/products (projeções incluem specifications)
  - Inputs: filtros facetados (pmax_wp, voc_v, ip_rating, etc.)
  - Outputs: lista paginada com specs; comparador opcional
  - Erros: 400 filtros inválidos

5) Persona: Merchant/Operador (Admin interno)
- JTBDs
  - Quando recebo uma RFQ, quero propor ajustes e preços, para fechar negócio.
  - Quando há bloqueio por aprovação, quero visibilidade e override responsável, para destravar pedidos urgentes.
- Jornada
  - Admin UI: /admin/companies, /admin/quotes, /admin/approvals, /admin/products
  - API (Admin)
    - GET /admin/quotes, POST /admin/quotes/{id}/propostas
    - POST /admin/approvals/{id}/override
    - PATCH /admin/products/{id} (+ specs vinculadas)
  - Outputs: auditoria e remote links criados/atualizados
  - Erros: 403 permissões, 409 conflitos de estado

Rotas principais (resumo operacional)
- Storefront (Next.js App Router)
  - /[countryCode]/login
  - /[countryCode]/products, /[countryCode]/products/[handle]
  - /[countryCode]/cart, /[countryCode]/checkout
  - /[countryCode]/rfq
  - /[countryCode]/account/company, /[countryCode]/account/company/new, /[countryCode]/account/company/employees
  - /[countryCode]/account/approvals
  - /[countryCode]/affiliate/apply, /[countryCode]/affiliate/dashboard
  - /[countryCode]/kits, /[countryCode]/learn
- Store API
  - POST /store/auth/email (login), POST /store/auth/logout
  - GET/POST /store/companies, GET /store/companies/me, POST /store/companies/me/employees
  - POST /store/carts, POST /store/carts/{id}/line-items, POST /store/carts/{id}/payment-sessions, POST /store/carts/{id}/complete
  - POST /store/quotes/requests, GET /store/quotes
  - GET /store/approvals/me, POST /store/approvals/{id}/approve|reject
  - POST /store/affiliates/apply, POST /store/affiliates/me/links, GET /store/affiliates/me/stats
  - POST /api/hooks/crm-event
- Admin API
  - GET /admin/companies, GET /admin/companies/{id}
  - GET /admin/quotes, POST /admin/quotes/{id}/propostas
  - POST /admin/approvals/{id}/override
  - GET/PATCH /admin/products/{id} (+ specs)

Inputs típicos (campos mínimos)
- Company: name, tax_id, billing/shipping (street, city, zip, country), contact (name,email,phone)
- Employee invite: email, role
- Line item: variant_id, quantity, metadata.project_id?
- RFQ: cart_id, notes, attachments?
- Approval action: approval_id, action=approve|reject, reason?
- Affiliate apply: payout_method, payout_details, tax_info
- CRM webhook: event, referral_code, amount, currency, deal_id, occurred_at

Outputs típicos (contratos resumidos)
- Company: { id, customer_group_id, approval_settings, created_at }
- Employee: { id, user_id?, role, status }
- Cart: { id, items[], totals, requires_approval?, metadata }
- Quote: { id, status, draft_order_id?, messages[] }
- Approval: { id, target='cart|order', status, requested_by, decided_by? }
- Affiliate: { profile_id, referral_code, links[], stats }
- CRM event ack: { tracked_event_id, status='accepted' }

Estados de erro e respostas
- 400 validação (campos obrigatórios/filtros)
- 401/403 autenticação/permissão (ex.: employee viewer tentando convidar)
- 404 recurso não encontrado (company/quote/approval inexistente)
- 409 conflito de estado (RFQ já em análise; approval já decidido)
- 422 regra de negócio (limite excedido; aprovação necessária)

Observações de implementação
- Respeitar queryConfig nas rotas Store/Admin para incluir relations de specs e links (ex.: *relations panel_specification).
- Sempre reconsultar após mutations via workflows para honrar projeções.
- Armazenar project_id em cart.metadata para segmentar approvals e orçamentos por obra.