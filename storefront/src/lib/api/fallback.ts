/**`r`n * API Fallback System`r`n * Fornece dados estÃ¡ticos do catÃ¡logo quando o backend estÃ¡ offline`r`n * `r`n * EstratÃ©gia:`r`n * 1. Tenta buscar do backend Medusa`r`n * 2. Em caso de falha, usa dados do catÃ¡logo unificado`r`n * 3. Cache local com TTL curto para performance`r`n */`r`n`r`nimport { cache } from 'react'`r`nimport path from 'path'`r`nimport fs from 'fs/promises'`r`n`r`n// ==========================================`r`n// Types`r`n// ==========================================`r`n`r`nexport type FallbackProduct = {`r`n    id: string`r`n    title: string`r`n    handle: string`r`n    description: string`r`n    thumbnail: string | null`r`n    category: string`r`n    manufacturer: string`r`n    sku: string`r`n    price: number`r`n    currency: string`r`n    availability: boolean`r`n    stock: number`r`n    metadata: Record<string, any>`r`n    specifications: Record<string, any>`r`n}`r`n`r`nexport type FallbackCart = {`r`n    id: string`r`n    items: FallbackCartItem[]`r`n    subtotal: number`r`n    total: number`r`n    currency: string`r`n}`r`n`r`nexport type FallbackCartItem = {`r`n    id: string`r`n    product_id: string`r`n    title: string`r`n    sku: string`r`n    quantity: number`r`n    unit_price: number`r`n    total: number`r`n    thumbnail: string | null`r`n}`r`n`r`nexport type BackendStatus = {`r`n    online: boolean`r`n    lastCheck: Date`r`n    errorCount: number`r`n    lastError?: string`r`n}`r`n`r`n// ==========================================`r`n// Configuration`r`n// ==========================================`r`n`r`nconst CATALOG_PATH = process.env.CATALOG_PATH ||`r`n    path.join(process.cwd(), '../../../ysh-erp/data/catalog/unified_schemas')`r`n`r`nconst IMAGE_MAP_PATH = process.env.IMAGE_MAP_PATH ||`r`n    path.join(process.cwd(), '../../../ysh-erp/data/catalog/images/IMAGE_MAP.json')`r`n`r`nconst BACKEND_URL = process.env.NEXT_PUBLIC_MEDUSA_BACKEND_URL || 'http://localhost:9000'`r`nconst HEALTH_CHECK_ENDPOINT = '/health'`r`nconst HEALTH_CHECK_TIMEOUT = 5000 // 5s`r`nconst HEALTH_CHECK_INTERVAL = 30000 // 30s`r`nconst MAX_ERROR_COUNT = 3`r`n`r`n// ==========================================`r`n// Backend Health Monitoring`r`n// ==========================================`r`n`r`nlet backendStatus: BackendStatus = {`r`n    online: true,`r`n    lastCheck: new Date(),`r`n    errorCount: 0`r`n}`r`n`r`n/**`r`n * Verifica se o backend estÃ¡ online`r`n */`r`nexport async function checkBackendHealth(): Promise<boolean> {`r`n    try {`r`n        const controller = new AbortController()`r`n        const timeout = setTimeout(() => controller.abort(), HEALTH_CHECK_TIMEOUT)`r`n`r`n        const response = await fetch(`${BACKEND_URL}${HEALTH_CHECK_ENDPOINT}`, {`r`n            method: 'GET',`r`n            signal: controller.signal,`r`n            cache: 'no-store'`r`n        })`r`n`r`n        clearTimeout(timeout)`r`n`r`n        const isOnline = response.ok`r`n`r`n        backendStatus = {`r`n            online: isOnline,`r`n            lastCheck: new Date(),`r`n            errorCount: isOnline ? 0 : backendStatus.errorCount + 1`r`n        }`r`n`r`n        return isOnline`r`n    } catch (error) {`r`n        backendStatus = {`r`n            online: false,`r`n            lastCheck: new Date(),`r`n            errorCount: backendStatus.errorCount + 1,`r`n            lastError: error instanceof Error ? error.message : 'Unknown error'`r`n        }`r`n`r`n        return false`r`n    }`r`n}`r`n`r`n/**`r`n * Retorna o status atual do backend`r`n */`r`nexport function getBackendStatus(): BackendStatus {`r`n    return backendStatus`r`n}`r`n`r`n/**`r`n * Verifica se deve usar fallback baseado no status e contagem de erros`r`n */`r`nexport function shouldUseFallback(): boolean {`r`n    const timeSinceLastCheck = Date.now() - backendStatus.lastCheck.getTime()`r`n`r`n    // Se passou mais de 30s desde Ãºltima verificaÃ§Ã£o, considera offline`r`n    if (timeSinceLastCheck > HEALTH_CHECK_INTERVAL) {`r`n        return true`r`n    }`r`n`r`n    // Se teve muitos erros consecutivos, usa fallback`r`n    if (backendStatus.errorCount >= MAX_ERROR_COUNT) {`r`n        return true`r`n    }`r`n`r`n    return !backendStatus.online`r`n}`r`n`r`n// ==========================================`r`n// Catalog Data Loading (Cached)`r`n// ==========================================`r`n`r`n// SKU Registry loader (optional)`r`ntype SkuRegistry = {`r`n    map?: Record<string, string>`r`n    items?: Array<{ category: string; id: string; sku: string }>`r`n}`r`n`r`nconst loadSkuRegistry = cache(async (): Promise<Record<string, string>> => {`r`n    try {`r`n        // Registry esperado em `${CATALOG_PATH}/sku_registry.json``r`n        const registryPath = path.join(CATALOG_PATH, 'sku_registry.json')`r`n        const raw = await fs.readFile(registryPath, 'utf-8')`r`n        const parsed: SkuRegistry = JSON.parse(raw)`r`n        if (parsed?.map) return parsed.map`r`n        if (parsed?.items && Array.isArray(parsed.items)) {`r`n            const m: Record<string, string> = {}`r`n            for (const it of parsed.items) {`r`n                if (it?.category && it?.id && it?.sku) m[`${it.category}:${it.id}`] = it.sku`r`n            }`r`n            return m`r`n        }`r`n        return {}`r`n    } catch {`r`n        return {}`r`n    }`r`n})`r`n`r`n/**`r`n * Carrega dados de uma categoria do catÃ¡logo unificado`r`n */`r`nconst loadCatalogCategory = cache(async (category: string): Promise<any[]> => {`r`n    try {`r`n        const categoryMap: Record<string, string> = {`r`n            'inversores': 'inverters',`r`n            'inverters': 'inverters',`r`n            'paineis': 'panels',`r`n            'panels': 'panels',`r`n            'baterias': 'batteries',`r`n            'batteries': 'batteries',`r`n            'kits': 'kits',`r`n            'estruturas': 'structures',`r`n            'structures': 'structures',`r`n            'cabos': 'cables',`r`n            'cables': 'cables',`r`n            'conectores': 'connectors',`r`n            'connectors': 'connectors',`r`n            'protecoes': 'protections',`r`n            'protections': 'protections',`r`n            'monitoramento': 'monitoring',`r`n            'monitoring': 'monitoring',`r`n            'ferramentas': 'tools',`r`n            'tools': 'tools',`r`n            'acessorios': 'accessories',`r`n            'accessories': 'accessories',`r`n            'servicos': 'services',`r`n            'services': 'services'`r`n        }`r`n`r`n        const mappedCategory = categoryMap[category.toLowerCase()] || category`r`n        const filePath = path.join(CATALOG_PATH, `${mappedCategory}_unified.json`)`r`n`r`n        const fileContent = await fs.readFile(filePath, 'utf-8')`r`n        const data = JSON.parse(fileContent)`r`n`r`n        const arr: any[] = Array.isArray(data) ? data : []`r`n`r`n        // Enriquecer com SKU canÃ´nico do registry (se existir)`r`n        const registry = await loadSkuRegistry()`r`n        const withSku = arr.map((it: any) => {`r`n            const id = (it?.id ?? '').toString()`r`n            const key = `${mappedCategory}:${id}``r`n            const canonical = registry[key]`r`n            const sku = (it?.sku || canonical || id || '').toString()`r`n            // garantir category para downstream`r`n            const cat = it?.category || mappedCategory`r`n            return { ...it, sku, category: cat }`r`n        })`r`n`r`n        return withSku`r`n    } catch (error) {`r`n        console.warn(`[Fallback] Failed to load category ${category}:`, error)`r`n        return []`r`n    }`r`n})`r`n`r`n/**`r`n * Carrega mapa de imagens`r`n */`r`nconst loadImageMap = cache(async (): Promise<Record<string, string>> => {`r`n    try {`r`n        const fileContent = await fs.readFile(IMAGE_MAP_PATH, 'utf-8')`r`n        return JSON.parse(fileContent)`r`n    } catch (error) {`r`n        console.warn('[Fallback] Failed to load image map:', error)`r`n        return {}`r`n    }`r`n})`r`n`r`n/**`r`n * Carrega todas as categorias disponÃ­veis`r`n */`r`nconst loadAllCategories = cache(async (): Promise<string[]> => {`r`n    try {`r`n        const files = await fs.readdir(CATALOG_PATH)`r`n        const categories = files`r`n            .filter(f => f.endsWith('_unified.json'))`r`n            .map(f => f.replace('_unified.json', ''))`r`n`r`n        return categories`r`n    } catch (error) {`r`n        console.warn('[Fallback] Failed to list categories:', error)`r`n        return ['inverters', 'panels', 'batteries', 'kits', 'structures', 'cables']`r`n    }`r`n})`r`n`r`n// ==========================================`r`n// Data Transformation`r`n// ==========================================`r`n`r`n/**`r`n * Converte produto do catÃ¡logo para formato Medusa-like`r`n */`r`nfunction parseNumberFromPriceString(p?: string): number | undefined {`r`n    if (!p) return undefined`r`n    const cleaned = p.replace(/[^0-9.,]/g, '')`r`n    let normalized = cleaned`r`n    if (cleaned.includes('.') && cleaned.includes(',')) normalized = cleaned.replace(/\./g, '').replace(',', '.')`r`n    else if (cleaned.includes(',')) normalized = cleaned.replace(',', '.')`r`n    const v = parseFloat(normalized as any)`r`n    return isNaN(v) ? undefined : v`r`n}`r`nfunction transformCatalogToProduct(item: any, imageMap: Record<string, string>): FallbackProduct {`r`n    const sku = item.sku || item.id || ''`r`n    const image = imageMap[sku] || item.image || null`r`n`r`n    // Extrai preÃ§o (prioriza o primeiro preÃ§o disponÃ­vel)`r`n    const price = item.price?.value ||`r`n        item.prices?.[0]?.amount ||`r`n        item.metadata?.price ||`r`n        0`r`n`r`n    return {`r`n        id: sku,`r`n        title: item.name || item.title || 'Produto Solar',`r`n        handle: sku.toLowerCase().replace(/[^a-z0-9]+/g, '-'),`r`n        description: item.description || item.metadata?.description || '',`r`n        thumbnail: image,`r`n        category: item.category || '',`r`n        manufacturer: item.manufacturer || item.brand || '',`r`n        sku: sku,`r`n        price: price,`r`n        currency: 'BRL',`r`n        availability: item.availability !== false && item.availability !== 'unavailable',`r`n        stock: item.stock || (item.availability ? 10 : 0),`r`n        metadata: { ...(item.metadata || {}), price_formatted: new Intl.NumberFormat('pt-BR', { style: 'currency', currency: 'BRL' }).format(price) },`r`n        specifications: item.specifications || item.specs || {}`r`n    }`r`n}`r`n`r`n// ==========================================`r`n// Fallback API Functions`r`n// ==========================================`r`n`r`n/**`r`n * Lista produtos com paginaÃ§Ã£o`r`n */`r`nexport async function fallbackListProducts(options?: {`r`n    category?: string`r`n    limit?: number`r`n    offset?: number`r`n    search?: string`r`n}): Promise<{ products: FallbackProduct[], count: number }> {`r`n    const { category, limit = 12, offset = 0, search } = options || {}`r`n`r`n    try {`r`n        let allProducts: any[] = []`r`n`r`n        if (category) {`r`n            // Carrega apenas a categoria especificada`r`n            allProducts = await loadCatalogCategory(category)`r`n        } else {`r`n            // Carrega todas as categorias`r`n            const categories = await loadAllCategories()`r`n            const results = await Promise.all(`r`n                categories.map(cat => loadCatalogCategory(cat))`r`n            )`r`n            allProducts = results.flat()`r`n        }`r`n`r`n        const imageMap = await loadImageMap()`r`n`r`n        // Filtra por busca se fornecida`r`n        let filtered = allProducts`r`n        if (search) {`r`n            const searchLower = search.toLowerCase()`r`n            filtered = allProducts.filter(item => {`r`n                const name = (item.name || item.title || '').toLowerCase()`r`n                const sku = (item.sku || '').toLowerCase()`r`n                const manufacturer = (item.manufacturer || item.brand || '').toLowerCase()`r`n`r`n                return name.includes(searchLower) ||`r`n                    sku.includes(searchLower) ||`r`n                    manufacturer.includes(searchLower)`r`n            })`r`n        }`r`n`r`n        // PaginaÃ§Ã£o`r`n        const paginatedProducts = filtered.slice(offset, offset + limit)`r`n`r`n        // Transforma para formato Medusa-like`r`n        const products = paginatedProducts.map(item =>`r`n            transformCatalogToProduct(item, imageMap)`r`n        )`r`n`r`n        return {`r`n            products,`r`n            count: filtered.length`r`n        }`r`n    } catch (error) {`r`n        console.error('[Fallback] Error listing products:', error)`r`n        return { products: [], count: 0 }`r`n    }`r`n}`r`n`r`n/**`r`n * Busca produto por ID/SKU`r`n */`r`nexport async function fallbackGetProduct(id: string): Promise<FallbackProduct | null> {`r`n    try {`r`n        const categories = await loadAllCategories()`r`n        const imageMap = await loadImageMap()`r`n`r`n        // Busca em todas as categorias`r`n        for (const category of categories) {`r`n            const items = await loadCatalogCategory(category)`r`n            const found = items.find(item =>`r`n                item.sku === id ||`r`n                item.id === id ||`r`n                item.name?.toLowerCase().replace(/[^a-z0-9]+/g, '-') === id`r`n            )`r`n`r`n            if (found) {`r`n                return transformCatalogToProduct(found, imageMap)`r`n            }`r`n        }`r`n`r`n        return null`r`n    } catch (error) {`r`n        console.error('[Fallback] Error getting product:', error)`r`n        return null`r`n    }`r`n}`r`n`r`n/**`r`n * Busca produtos por categoria`r`n */`r`nexport async function fallbackGetProductsByCategory(`r`n    category: string,`r`n    limit = 12`r`n): Promise<FallbackProduct[]> {`r`n    const { products } = await fallbackListProducts({ category, limit })`r`n    return products`r`n}`r`n`r`n/**`r`n * Busca recomendaÃ§Ãµes de produtos relacionados`r`n */`r`nexport async function fallbackGetRelatedProducts(`r`n    productId: string,`r`n    limit = 4`r`n): Promise<FallbackProduct[]> {`r`n    try {`r`n        const product = await fallbackGetProduct(productId)`r`n        if (!product) return []`r`n`r`n        // Busca produtos da mesma categoria e fabricante`r`n        const { products } = await fallbackListProducts({`r`n            category: product.category,`r`n            limit: limit + 5 // Pega mais para filtrar`r`n        })`r`n`r`n        // Filtra produtos relacionados (mesma categoria, fabricante similar)`r`n        const related = products`r`n            .filter(p => p.id !== productId)`r`n            .filter(p =>`r`n                p.manufacturer === product.manufacturer ||`r`n                p.category === product.category`r`n            )`r`n            .slice(0, limit)`r`n`r`n        return related`r`n    } catch (error) {`r`n        console.error('[Fallback] Error getting related products:', error)`r`n        return []`r`n    }`r`n}`r`n`r`n/**`r`n * Busca produtos em destaque`r`n */`r`nexport async function fallbackGetFeaturedProducts(limit = 8): Promise<FallbackProduct[]> {`r`n    try {`r`n        const { products } = await fallbackListProducts({ limit: 100 })`r`n`r`n        // Seleciona produtos em estoque com melhor disponibilidade`r`n        const featured = products`r`n            .filter(p => p.availability && p.stock > 0)`r`n            .sort((a, b) => b.stock - a.stock)`r`n            .slice(0, limit)`r`n`r`n        return featured`r`n    } catch (error) {`r`n        console.error('[Fallback] Error getting featured products:', error)`r`n        return []`r`n    }`r`n}`r`n`r`n// ==========================================`r`n// Cart Fallback (Local Storage)`r`n// ==========================================`r`n`r`nconst CART_STORAGE_KEY = 'ysh_fallback_cart'`r`n`r`n/**`r`n * Cria carrinho fallback`r`n */`r`nexport function fallbackCreateCart(): FallbackCart {`r`n    const cart: FallbackCart = {`r`n        id: `fallback_cart_${Date.now()}`,`r`n        items: [],`r`n        subtotal: 0,`r`n        total: 0,`r`n        currency: 'BRL'`r`n    }`r`n`r`n    if (typeof window !== 'undefined') {`r`n        localStorage.setItem(CART_STORAGE_KEY, JSON.stringify(cart))`r`n    }`r`n`r`n    return cart`r`n}`r`n`r`n/**`r`n * Carrega carrinho fallback`r`n */`r`nexport function fallbackGetCart(): FallbackCart | null {`r`n    if (typeof window === 'undefined') return null`r`n`r`n    try {`r`n        const stored = localStorage.getItem(CART_STORAGE_KEY)`r`n        if (!stored) return null`r`n`r`n        return JSON.parse(stored)`r`n    } catch (error) {`r`n        console.error('[Fallback] Error loading cart:', error)`r`n        return null`r`n    }`r`n}`r`n`r`n/**`r`n * Adiciona item ao carrinho fallback`r`n */`r`nexport async function fallbackAddToCart(`r`n    productId: string,`r`n    quantity: number`r`n): Promise<FallbackCart> {`r`n    let cart = fallbackGetCart()`r`n    if (!cart) {`r`n        cart = fallbackCreateCart()`r`n    }`r`n`r`n    const product = await fallbackGetProduct(productId)`r`n    if (!product) {`r`n        throw new Error('Product not found')`r`n    }`r`n`r`n    // Verifica se item jÃ¡ existe`r`n    const existingIndex = cart.items.findIndex(item => item.product_id === productId)`r`n`r`n    if (existingIndex >= 0) {`r`n        // Atualiza quantidade`r`n        cart.items[existingIndex].quantity += quantity`r`n        cart.items[existingIndex].total =`r`n            cart.items[existingIndex].quantity * cart.items[existingIndex].unit_price`r`n    } else {`r`n        // Adiciona novo item`r`n        cart.items.push({`r`n            id: `item_${Date.now()}`,`r`n            product_id: productId,`r`n            title: product.title,`r`n            sku: product.sku,`r`n            quantity,`r`n            unit_price: product.price,`r`n            total: quantity * product.price,`r`n            thumbnail: product.thumbnail`r`n        })`r`n    }`r`n`r`n    // Recalcula totais`r`n    cart.subtotal = cart.items.reduce((sum, item) => sum + item.total, 0)`r`n    cart.total = cart.subtotal`r`n`r`n    // Salva no localStorage`r`n    if (typeof window !== 'undefined') {`r`n        localStorage.setItem(CART_STORAGE_KEY, JSON.stringify(cart))`r`n    }`r`n`r`n    return cart`r`n}`r`n`r`n/**`r`n * Remove item do carrinho fallback`r`n */`r`nexport function fallbackRemoveFromCart(itemId: string): FallbackCart {`r`n    let cart = fallbackGetCart()`r`n    if (!cart) {`r`n        cart = fallbackCreateCart()`r`n    }`r`n`r`n    cart.items = cart.items.filter(item => item.id !== itemId)`r`n`r`n    // Recalcula totais`r`n    cart.subtotal = cart.items.reduce((sum, item) => sum + item.total, 0)`r`n    cart.total = cart.subtotal`r`n`r`n    // Salva no localStorage`r`n    if (typeof window !== 'undefined') {`r`n        localStorage.setItem(CART_STORAGE_KEY, JSON.stringify(cart))`r`n    }`r`n`r`n    return cart`r`n}`r`n`r`n/**`r`n * Atualiza quantidade de item no carrinho`r`n */`r`nexport function fallbackUpdateCartItem(`r`n    itemId: string,`r`n    quantity: number`r`n): FallbackCart {`r`n    let cart = fallbackGetCart()`r`n    if (!cart) {`r`n        cart = fallbackCreateCart()`r`n    }`r`n`r`n    const item = cart.items.find(i => i.id === itemId)`r`n    if (item) {`r`n        item.quantity = quantity`r`n        item.total = quantity * item.unit_price`r`n    }`r`n`r`n    // Recalcula totais`r`n    cart.subtotal = cart.items.reduce((sum, item) => sum + item.total, 0)`r`n    cart.total = cart.subtotal`r`n`r`n    // Salva no localStorage`r`n    if (typeof window !== 'undefined') {`r`n        localStorage.setItem(CART_STORAGE_KEY, JSON.stringify(cart))`r`n    }`r`n`r`n    return cart`r`n}`r`n`r`n/**`r`n * Limpa carrinho fallback`r`n */`r`nexport function fallbackClearCart(): void {`r`n    if (typeof window !== 'undefined') {`r`n        localStorage.removeItem(CART_STORAGE_KEY)`r`n    }`r`n}`r`n`r`n// ==========================================`r`n// Export Status`r`n// ==========================================`r`n`r`nexport const FallbackAPI = {`r`n    // Health`r`n    checkHealth: checkBackendHealth,`r`n    getStatus: getBackendStatus,`r`n    shouldUseFallback,`r`n`r`n    // Products`r`n    listProducts: fallbackListProducts,`r`n    getProduct: fallbackGetProduct,`r`n    getProductsByCategory: fallbackGetProductsByCategory,`r`n    getRelatedProducts: fallbackGetRelatedProducts,`r`n    getFeaturedProducts: fallbackGetFeaturedProducts,`r`n`r`n    // Cart`r`n    createCart: fallbackCreateCart,`r`n    getCart: fallbackGetCart,`r`n    addToCart: fallbackAddToCart,`r`n    removeFromCart: fallbackRemoveFromCart,`r`n    updateCartItem: fallbackUpdateCartItem,`r`n    clearCart: fallbackClearCart`r`n}

