# üöÄ API Improvements Implementation Guide

**Data**: 07 de outubro de 2025  
**Projeto**: YSH Store - Storefront API Modernization  
**Status**: ‚úÖ Funda√ß√£o Implementada

---

## üì¶ Arquivos Criados

### 1. **API Response Builder** ‚úÖ

**Arquivo**: `src/lib/api/response.ts`

**Funcionalidades**:

- ‚úÖ Standardized `APIResponse<T>` type
- ‚úÖ Success/error response builders
- ‚úÖ Request ID tracking (auto-generated ou from headers)
- ‚úÖ Response time tracking
- ‚úÖ Type-safe error codes
- ‚úÖ Helper methods (validationError, notFound, rateLimitExceeded, etc.)
- ‚úÖ Development stack traces

**Uso**:

```typescript
import { createResponseBuilder } from '@/lib/api/response'

export async function GET(request: NextRequest) {
  const response = createResponseBuilder(request)
  
  try {
    const data = await fetchData()
    return response.success(data)
  } catch (error) {
    return response.error('INTERNAL_ERROR', error.message)
  }
}
```

---

### 2. **Input Validation with Zod** ‚úÖ

**Arquivo**: `src/lib/api/validation.ts`

**Schemas Definidos**:

- ‚úÖ `ProductsQuerySchema` - Validates product queries
- ‚úÖ `KitsQuerySchema` - Validates kit queries
- ‚úÖ `SearchQuerySchema` - Validates search queries
- ‚úÖ `SolarSimulationSchema` - Validates simulation inputs
- ‚úÖ `GeocodingSchema` - Validates geocoding requests
- ‚úÖ `PaginationSchema` - Reusable pagination
- ‚úÖ Custom refinements (minPrice ‚â§ maxPrice)

**Helper Functions**:

- ‚úÖ `validateQuery()` - Validate URLSearchParams
- ‚úÖ `validateBody()` - Validate JSON body
- ‚úÖ `validateParams()` - Validate path params
- ‚úÖ `formatZodError()` - Format errors for API response

**Uso**:

```typescript
import { validateQuery, ProductsQuerySchema, formatZodError } from '@/lib/api/validation'

const validation = validateQuery(ProductsQuerySchema, searchParams)

if (!validation.success) {
  return response.validationError(
    'Invalid query parameters',
    formatZodError(validation.error)
  )
}

const { category, limit, offset } = validation.data // Type-safe!
```

---

### 3. **Cache Manager** ‚úÖ

**Arquivo**: `src/lib/cache/redis.ts`

**Funcionalidades**:

- ‚úÖ In-memory cache implementation (ready for Redis upgrade)
- ‚úÖ TTL support (configurable per resource type)
- ‚úÖ Key namespacing (`ysh:api:...`)
- ‚úÖ Pattern-based invalidation (`products:*`)
- ‚úÖ Cache-aside pattern with `getOrSet()`
- ‚úÖ Health checks
- ‚úÖ Stats/monitoring

**Pre-configured TTLs**:

```typescript
export const CacheTTL = {
  PRODUCTS: 3600,      // 1 hour
  KITS: 3600,          // 1 hour
  CATEGORIES: 7200,    // 2 hours
  DISTRIBUTORS: 7200,  // 2 hours
  SEARCH: 1800,        // 30 minutes
  FEATURED: 3600       // 1 hour
}
```

**Key Builders**:

```typescript
export const CacheKeys = {
  products: (category, filters) => `products:${category}:${JSON.stringify(filters)}`,
  product: (id) => `product:${id}`,
  kits: (filters) => `kits:${JSON.stringify(filters)}`,
  // ... more builders
}
```

**Uso**:

```typescript
import { CacheManager, CacheKeys, CacheTTL } from '@/lib/cache/redis'

// Get or compute
const data = await CacheManager.getOrSet(
  CacheKeys.products('panels', { distributor: 'FOTUS' }),
  async () => loadProducts(...),
  CacheTTL.PRODUCTS
)

// Invalidate by pattern
await CacheManager.invalidate('products:*')
```

---

### 4. **Example Usage Guide** ‚úÖ

**Arquivo**: `src/lib/api/example.ts`

**Demonstra**:

- ‚úÖ Complete GET endpoint with caching
- ‚úÖ POST endpoint with body validation
- ‚úÖ Error handling patterns
- ‚úÖ Cache invalidation strategies
- ‚úÖ Performance monitoring
- ‚úÖ Request tracking

---

### 5. **Architecture Evaluation** ‚úÖ

**Arquivo**: `API_ARCHITECTURE_EVALUATION.md`

**Conte√∫do**:

- ‚úÖ Complete API inventory (11 storefront + backend)
- ‚úÖ Cache strategy analysis
- ‚úÖ Error handling review
- ‚úÖ Response format analysis
- ‚úÖ Security assessment
- ‚úÖ Prioritized recommendations
- ‚úÖ Implementation roadmap
- ‚úÖ Cost estimates

---

## üõ†Ô∏è Pr√≥ximos Passos

### Fase 1: Migrar Endpoints Existentes (ALTA PRIORIDADE)

#### 1.1. Atualizar `/api/catalog/products/route.ts`

**Mudan√ßas**:

```typescript
// ANTES
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const category = searchParams.get('category')
    
    if (!category) {
      return NextResponse.json({ error: 'Category required' }, { status: 400 })
    }
    
    // Manual cache check
    const cached = cache.get(cacheKey)
    if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
      return NextResponse.json(cached.data)
    }
    
    // Load data...
    return NextResponse.json({ success: true, data, timestamp })
  } catch (error) {
    return NextResponse.json({ error: error.message }, { status: 500 })
  }
}

// DEPOIS
import { createResponseBuilder } from '@/lib/api/response'
import { validateQuery, ProductsQuerySchema, formatZodError } from '@/lib/api/validation'
import { CacheManager, CacheKeys, CacheTTL } from '@/lib/cache/redis'

export async function GET(request: NextRequest) {
  const response = createResponseBuilder(request)
  
  try {
    // Validate
    const { searchParams } = new URL(request.url)
    const validation = validateQuery(ProductsQuerySchema, searchParams)
    
    if (!validation.success) {
      return response.validationError(
        'Invalid query parameters',
        formatZodError(validation.error)
      )
    }
    
    const query = validation.data
    
    // Cache-aside pattern
    const data = await CacheManager.getOrSet(
      CacheKeys.products(query.category, query),
      () => loadProducts(query),
      CacheTTL.PRODUCTS
    )
    
    return response.success(data, {
      headers: {
        'Cache-Control': `public, s-maxage=${CacheTTL.PRODUCTS}`
      }
    })
  } catch (error) {
    return response.error(
      'PRODUCTS_LOAD_FAILED',
      'Failed to load products',
      { status: 500, includeStack: true }
    )
  }
}
```

**Benef√≠cios**:

- ‚úÖ Valida√ß√£o autom√°tica com mensagens estruturadas
- ‚úÖ Cache distribu√≠do (pronto para Redis)
- ‚úÖ Response format padronizado
- ‚úÖ Request tracking
- ‚úÖ Error codes estruturados

#### 1.2. Endpoints a Migrar (Ordem de Prioridade)

**Sprint 1** (Esta semana):

1. ‚úÖ `/api/catalog/products` - Produtos (mais usado)
2. ‚úÖ `/api/catalog/kits` - Kits (segundo mais usado)
3. ‚úÖ `/api/catalog/search` - Busca (terceiro mais usado)

**Sprint 2** (Pr√≥xima semana):
4. ‚úÖ `/api/catalog/featured` - Destaque
5. ‚úÖ `/api/catalog/product/[id]` - Detalhes produto
6. ‚úÖ `/api/catalog/kit/[id]` - Detalhes kit

**Sprint 3** (Semana seguinte):
7. ‚úÖ `/api/catalog/categories` - Categorias
8. ‚úÖ `/api/catalog/distributors` - Distribuidores
9. ‚úÖ `/api/onboarding/simulate` - Simula√ß√£o
10. ‚úÖ `/api/onboarding/geocode` - Geocodifica√ß√£o

---

### Fase 2: Adicionar Monitoramento (ALTA PRIORIDADE)

#### 2.1. Setup Sentry

**Instalar**:

```powershell
npm install @sentry/nextjs
npx @sentry/wizard@latest -i nextjs
```

**Configurar** (`sentry.config.ts`):

```typescript
import * as Sentry from "@sentry/nextjs"

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  
  // Performance Monitoring
  tracesSampleRate: 0.1, // 10% das requests
  
  // Environment
  environment: process.env.NODE_ENV,
  
  // Release tracking
  release: process.env.VERCEL_GIT_COMMIT_SHA
})
```

**Usar em APIs**:

```typescript
import * as Sentry from '@sentry/nextjs'

export async function GET(request: NextRequest) {
  const transaction = Sentry.startTransaction({
    name: 'GET /api/catalog/products',
    op: 'api.request'
  })
  
  try {
    // ... logic
    return response.success(data)
  } catch (error) {
    Sentry.captureException(error, {
      tags: { endpoint: '/api/catalog/products' },
      extra: { query: searchParams.toString() }
    })
    
    return response.error(...)
  } finally {
    transaction.finish()
  }
}
```

---

### Fase 3: Rate Limiting (M√âDIA PRIORIDADE)

#### 3.1. Setup Upstash

**Instalar**:

```powershell
npm install @upstash/ratelimit @upstash/redis
```

**Criar middleware** (`middleware.ts`):

```typescript
import { Ratelimit } from '@upstash/ratelimit'
import { Redis } from '@upstash/redis'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

const redis = new Redis({
  url: process.env.UPSTASH_REDIS_REST_URL!,
  token: process.env.UPSTASH_REDIS_REST_TOKEN!
})

const rateLimiter = new Ratelimit({
  redis,
  limiter: Ratelimit.slidingWindow(100, '1 h'),
  analytics: true
})

export async function middleware(request: NextRequest) {
  // Only rate limit API routes
  if (!request.nextUrl.pathname.startsWith('/api/')) {
    return NextResponse.next()
  }
  
  // Skip health check
  if (request.nextUrl.pathname === '/api/health') {
    return NextResponse.next()
  }
  
  const ip = request.ip || 'anonymous'
  const { success, limit, remaining, reset } = await rateLimiter.limit(ip)
  
  if (!success) {
    return NextResponse.json({
      success: false,
      error: {
        code: 'RATE_LIMIT_EXCEEDED',
        message: 'Too many requests'
      }
    }, {
      status: 429,
      headers: {
        'X-RateLimit-Limit': limit.toString(),
        'X-RateLimit-Remaining': remaining.toString(),
        'X-RateLimit-Reset': new Date(reset).toISOString()
      }
    })
  }
  
  const response = NextResponse.next()
  response.headers.set('X-RateLimit-Limit', limit.toString())
  response.headers.set('X-RateLimit-Remaining', remaining.toString())
  
  return response
}

export const config = {
  matcher: '/api/:path*'
}
```

---

### Fase 4: Database Migration (BAIXA PRIORIDADE)

**Por que migrar para DB?**

- ‚úÖ Full-text search nativo
- ‚úÖ Queries otimizadas com √≠ndices
- ‚úÖ Aggregations (stats, grouping)
- ‚úÖ Relacionamentos (products ‚Üî kits)
- ‚úÖ Transactions
- ‚úÖ Migrations versionadas

**Stack Recomendada**:

- **PostgreSQL**: Database
- **Prisma**: ORM
- **Supabase**: Hosting (free tier: 500MB)

**Schema Example**:

```prisma
model Product {
  id            String   @id @default(cuid())
  sku           String   @unique
  name          String
  category      String
  distributor   String
  manufacturer  String?
  price_brl     Float
  
  // Search
  search_vector Unsupported("tsvector")?
  
  // Metadata
  specifications Json
  image_url     String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  
  // Indexes
  @@index([category])
  @@index([distributor])
  @@index([manufacturer])
  @@fulltext([name, sku])
}
```

**Migration Script**:

```typescript
// scripts/migrate-json-to-db.ts
import { PrismaClient } from '@prisma/client'
import * as fs from 'fs/promises'

const prisma = new PrismaClient()

async function migrate() {
  // Read JSON files
  const files = ['panels', 'inverters', 'batteries', ...]
  
  for (const category of files) {
    const data = await fs.readFile(`${catalogPath}/${category}.json`, 'utf-8')
    const products = JSON.parse(data)
    
    // Bulk insert
    await prisma.product.createMany({
      data: products.map(p => ({
        sku: p.sku,
        name: p.name,
        category,
        distributor: p.distributor,
        manufacturer: p.manufacturer,
        price_brl: p.price_brl,
        specifications: p,
        image_url: p.image_url
      })),
      skipDuplicates: true
    })
    
    console.log(`‚úÖ Migrated ${products.length} products from ${category}`)
  }
}

migrate()
```

---

## üìä Progresso Atual

### ‚úÖ Implementado (Fase 1)

- [x] ResponseBuilder com request tracking
- [x] Zod schemas para todas as APIs
- [x] CacheManager com in-memory fallback
- [x] Cache key builders
- [x] TTL configuration
- [x] Example usage guide
- [x] Architecture evaluation document

### üîÑ Em Progresso (Fase 2)

- [ ] Migrar `/api/catalog/products` para novo padr√£o
- [ ] Migrar `/api/catalog/kits` para novo padr√£o
- [ ] Migrar `/api/catalog/search` para novo padr√£o

### ‚è≥ Pendente (Fase 3+)

- [ ] Setup Sentry
- [ ] Setup Upstash rate limiting
- [ ] Migrar todos os endpoints
- [ ] Adicionar testes automatizados
- [ ] Implementar API versioning (v1, v2)
- [ ] OpenAPI/Swagger docs
- [ ] Database migration (opcional)

---

## üéØ M√©tricas de Sucesso

### Before vs After

| M√©trica | Antes | Depois (Meta) |
|---------|-------|---------------|
| **Response Format** | 3 diferentes | 1 padronizado |
| **Error Tracking** | console.log | Sentry + structured logs |
| **Cache Hit Rate** | ~40% (estimado) | 70%+ |
| **API Latency (p95)** | ~500ms | <300ms |
| **Rate Limiting** | N√£o | 100 req/h |
| **Test Coverage** | 0% | 70%+ |
| **Request Tracking** | N√£o | 100% |
| **Validation Errors** | Generic | Structured |

---

## üí° Tips & Best Practices

### 1. **Sempre valide inputs**

```typescript
// ‚ùå N√£o fa√ßa
const category = searchParams.get('category')
if (!category) return error(...)

// ‚úÖ Fa√ßa
const validation = validateQuery(ProductsQuerySchema, searchParams)
if (!validation.success) return response.validationError(...)
```

### 2. **Use cache-aside pattern**

```typescript
// ‚ùå N√£o fa√ßa (manual)
const cached = cache.get(key)
if (cached) return cached
const data = await load()
cache.set(key, data)
return data

// ‚úÖ Fa√ßa (abstracted)
return await CacheManager.getOrSet(key, () => load(), TTL)
```

### 3. **Track todas as requests**

```typescript
// ‚úÖ Sempre use ResponseBuilder
const response = createResponseBuilder(request) // Auto request ID

// ‚úÖ Log com context
console.log(`[API] Request ${response.getRequestId()} took ${response.getElapsedTime()}ms`)
```

### 4. **Invalide cache quando necess√°rio**

```typescript
// Ap√≥s update no backend
await CacheManager.invalidate('products:panels*')
```

### 5. **Use error codes, n√£o strings**

```typescript
// ‚ùå N√£o fa√ßa
return response.error('ERROR', 'Something went wrong')

// ‚úÖ Fa√ßa
return response.error('PRODUCTS_LOAD_FAILED', 'Failed to load products')
```

---

## üö¶ Status & Next Action

**Current Status**: ‚úÖ Foundation Complete  
**Next Action**: Migrate first 3 endpoints (products, kits, search)  
**ETA**: 2-3 days  
**Blocker**: None

**Comando para come√ßar**:

```powershell
# Instalar depend√™ncia Zod (se necess√°rio)
npm install zod

# Testar cache manager
npm run dev
# Acesse http://localhost:3000/api/health

# Verificar tipos
npm run type-check
```

---

**√öltima Atualiza√ß√£o**: 07/10/2025  
**Autor**: GitHub Copilot Agent  
**Revis√£o**: Pending
